on init
  
  { The %voiceX_groups arrays contain the group numbers for each individual round robin voice.  }
  { You'll want to replace these group numbers with the IDs of the groups for each voice. }
  { You'll also want to make sure you adjust the array size for each voice accordingly. }

  declare %voice1_groups[4] := (4,5,6,7)
  declare $voice1_position := num_elements(%voice1_groups)
  declare $voice1_last_position

  declare %voice2_groups[2] := (1,2)
  declare $voice2_position := num_elements(%voice2_groups)
  declare $voice2_last_position

  declare %voice3_groups[3] := (3,4,8)
  declare $voice3_position := num_elements(%voice3_groups)
  declare $voice3_last_position

  { You can have fewer than 3 round robin "voices" if you want. If you add more than 3, 
    you will need to make more %voiceX variables following the same pattern as above. 
    You will also need to add additional cases to the two select statements below (search 
    for `select($current_voice)`) following the same patterns. For example, case 4 
    would need to reference a new variables called voice4_groups, voice4_position, and 
    voice_4last_position, respecitively.
  }
  declare $num_voices := 3

  { temp variables }

  declare $current_voice := 0
  declare $current_voice_num_groups
  declare %current_voice_groups[100] 
  declare $current_voice_position
  declare $current_voice_last_position
  declare $x
  declare $y

  declare @debug { remove this and the debug section below after testing }

  message("")
end on

on note
  disallow_group($ALL_GROUPS)
  
  $current_voice := 1
  { this giant for (while) loop iterates through all of the groups and advances the round robin counters for all of the voices }
  while($current_voice <= $num_voices)

    { copy voice variables for the current voice to temp variables }
    { this is what we have to do because there are no true multi-dimensional arrays}
    $x := 0
    select($current_voice)
      case 1
        $current_voice_position := $voice1_position
        $current_voice_last_position := $voice1_last_position
        $current_voice_num_groups := num_elements(%voice1_groups)
        while($x < $current_voice_num_groups)
          %current_voice_groups[$x] := %voice1_groups[$x]
          inc($x)
        end while
      case 2
        $current_voice_position := $voice2_position
        $current_voice_last_position := $voice2_last_position
        $current_voice_num_groups := num_elements(%voice2_groups)
        while($x < $current_voice_num_groups)
          %current_voice_groups[$x] := %voice2_groups[$x]
          inc($x)
        end while
      case 3
        $current_voice_position := $voice3_position
        $current_voice_last_position := $voice3_last_position
        $current_voice_num_groups := num_elements(%voice3_groups)
        while($x < $current_voice_num_groups)
          %current_voice_groups[$x] := %voice3_groups[$x]
          inc($x)
        end while
    end select

    { Round robin stuff }

    inc($current_voice_position)
    
    { if all groups in the list have been played, fill the list with all groups in random }
    { order, and make sure the last played group is not the first in the new list }
    if($current_voice_position >= $current_voice_num_groups)
    
      { remember last played group }
      $current_voice_last_position := %current_voice_groups[$current_voice_num_groups - 1]
      
      { fill list with all groups in random order }
      { %groups[0] := 0 }
      $current_voice_position := 1
      while($current_voice_position # $current_voice_num_groups)
        $x := random(0, $current_voice_position)
        $y := %current_voice_groups[$current_voice_position]
        %current_voice_groups[$current_voice_position] := %current_voice_groups[$x]
        %current_voice_groups[$x] := $y
        inc($current_voice_position)
      end while
      $current_voice_position := 0
      
      { if the last played group is first in the new list, swap first and last in the list }
      if(%current_voice_groups[0] = $current_voice_last_position)
        %current_voice_groups[0] := %current_voice_groups[$current_voice_num_groups - 1]
        %current_voice_groups[$current_voice_num_groups - 1] := $current_voice_last_position
      end if

      { debug: show list }
      $x := 0
      @debug := "voice " & $current_voice & " at: " & $current_voice_position & "; list:"
      while($x < $current_voice_num_groups)
        @debug := @debug & " " & %current_voice_groups[$x]
        inc($x)
      end while
      message(@debug)
      { debug end }
    end if
    
    { enable a group from the list }
    allow_group(%current_voice_groups[$current_voice_position])

    { copy temp variables back to voice variables}
    $x := 0
    select($current_voice)
      case 1
        while($x < $current_voice_num_groups)
          %voice1_groups[$x] := %current_voice_groups[$x]
          inc($x)
        end while
        $voice1_position := $current_voice_position
        $voice1_last_position := $current_voice_last_position
      case 2
        while($x < $current_voice_num_groups)
          %voice2_groups[$x] := %current_voice_groups[$x]
          inc($x)
        end while
        $voice2_position := $current_voice_position
        $voice2_last_position := $current_voice_last_position
      case 3
        while($x < $current_voice_num_groups)
          %voice3_groups[$x] := %current_voice_groups[$x]
          inc($x)
        end while
        $voice3_position := $current_voice_position
        $voice3_last_position := $current_voice_last_position
    end select

    inc($current_voice)
  end while
end on
